//! ACE Configuration Loader
//!
//! Responsible for loading ACE configuration from standalone config file, with automatic default config creation support.

use anyhow::Context;
use anyhow::Result;
use serde::Deserialize;
use serde::Serialize;
use std::path::Path;
use std::path::PathBuf;
use tokio::fs;

use super::types::ACEConfig;

/// ACE configuration file name
pub const ACE_CONFIG_FILENAME: &str = "codeACE-config.toml";

/// Default configuration file template
const DEFAULT_CONFIG_TOML: &str = r#"# ACE (Agentic Coding Environment) Configuration
#
# This file is automatically generated on first run.
# ACE learns from your coding sessions and provides intelligent context suggestions.

# ============================================================================
# Core Settings
# ============================================================================

[ace]
# Enable or disable ACE framework
enabled = true

# Storage path for learned knowledge (supports ~)
storage_path = "~/.codeACE/ace"

# Maximum number of entries before auto-archiving
max_entries = 500

# ============================================================================
# Reflector Settings (Knowledge Extraction)
# ============================================================================

[ace.reflector]
# Extract code patterns (e.g., file operations, build workflows)
extract_patterns = true

# Extract tool usage information
extract_tools = true

# Extract error handling strategies
extract_errors = true

# ============================================================================
# Context Settings (Knowledge Retrieval)
# ============================================================================

[ace.context]
# Maximum number of recent entries to consider
max_recent_entries = 10

# Include all successful cases in context search
include_all_successes = true

# Maximum characters for context injection
max_context_chars = 4000
"#;

/// ACE configuration TOML representation (for serialization/deserialization)
#[derive(Debug, Clone, Serialize, Deserialize)]
struct ACEConfigToml {
    ace: ACEConfig,
}

/// ACE configuration loader
pub struct ACEConfigLoader {
    config_path: PathBuf,
}

impl ACEConfigLoader {
    /// Create configuration loader
    ///
    /// # Parameters
    /// - `codex_home`: Codex home directory (typically ~/.codeACE)
    pub fn new(codex_home: &Path) -> Self {
        let config_path = codex_home.join(ACE_CONFIG_FILENAME);
        Self { config_path }
    }

    /// Load configuration (auto-create if not exists)
    ///
    /// Workflow:
    /// 1. Check if configuration file exists
    /// 2. Create default config if not exists
    /// 3. Read and parse configuration
    /// 4. Return configuration or error
    pub async fn load_or_create(&self) -> Result<ACEConfig> {
        // 1. Check if file exists
        if !self.config_path.exists() {
            tracing::info!(
                "ACE config not found at {:?}, creating default config...",
                self.config_path
            );
            self.create_default_config().await?;
        }

        // 2. Load configuration
        self.load().await
    }

    /// Load existing configuration
    async fn load(&self) -> Result<ACEConfig> {
        let content = fs::read_to_string(&self.config_path)
            .await
            .with_context(|| format!("Failed to read ACE config from {:?}", self.config_path))?;

        let config_toml: ACEConfigToml = toml::from_str(&content)
            .with_context(|| format!("Failed to parse ACE config from {:?}", self.config_path))?;

        tracing::debug!("Loaded ACE config: enabled={}", config_toml.ace.enabled);

        Ok(config_toml.ace)
    }

    /// Create default configuration file
    async fn create_default_config(&self) -> Result<()> {
        // Ensure parent directory exists
        if let Some(parent) = self.config_path.parent() {
            fs::create_dir_all(parent)
                .await
                .with_context(|| format!("Failed to create config directory: {parent:?}"))?;
        }

        // Write default configuration
        fs::write(&self.config_path, DEFAULT_CONFIG_TOML)
            .await
            .with_context(|| {
                format!(
                    "Failed to write default ACE config to {:?}",
                    self.config_path
                )
            })?;

        tracing::info!("Created default ACE config at {:?}", self.config_path);

        Ok(())
    }

    /// Save configuration (for CLI config modification)
    pub async fn save(&self, config: &ACEConfig) -> Result<()> {
        let config_toml = ACEConfigToml {
            ace: config.clone(),
        };

        let content = toml::to_string_pretty(&config_toml)
            .with_context(|| "Failed to serialize ACE config")?;

        fs::write(&self.config_path, content)
            .await
            .with_context(|| format!("Failed to write ACE config to {:?}", self.config_path))?;

        tracing::info!("Saved ACE config to {:?}", self.config_path);

        Ok(())
    }

    /// Get configuration file path
    pub fn config_path(&self) -> &Path {
        &self.config_path
    }
}

/// Convenience function: Load configuration from CODEACE_HOME
///
/// # Parameters
/// - `codex_home`: Codex home directory path
pub async fn load_ace_config(codex_home: &Path) -> Result<ACEConfig> {
    let loader = ACEConfigLoader::new(codex_home);
    loader.load_or_create().await
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[tokio::test]
    async fn test_create_default_config() {
        let temp_dir = TempDir::new().unwrap();
        let loader = ACEConfigLoader::new(temp_dir.path());

        // Config file should not exist
        assert!(!loader.config_path().exists());

        // Load should auto-create
        let config = loader.load_or_create().await.unwrap();

        // Verify default values
        assert!(config.enabled); // Default enabled
        assert_eq!(config.max_entries, 500);
        assert!(config.reflector.extract_patterns);
        assert!(config.reflector.extract_tools);
        assert!(config.reflector.extract_errors);

        // File should be created
        assert!(loader.config_path().exists());
    }

    #[tokio::test]
    async fn test_load_existing_config() {
        let temp_dir = TempDir::new().unwrap();
        let loader = ACEConfigLoader::new(temp_dir.path());

        // Create custom configuration
        let custom_config = r#"
[ace]
enabled = false
storage_path = "/custom/path"
max_entries = 100

[ace.reflector]
extract_patterns = false
extract_tools = true
extract_errors = false

[ace.context]
max_recent_entries = 5
include_all_successes = false
max_context_chars = 2000
"#;

        fs::write(loader.config_path(), custom_config)
            .await
            .unwrap();

        // Load configuration
        let config = loader.load_or_create().await.unwrap();

        // Verify custom values
        assert!(!config.enabled);
        assert_eq!(config.storage_path, "/custom/path");
        assert_eq!(config.max_entries, 100);
        assert!(!config.reflector.extract_patterns);
        assert!(config.reflector.extract_tools);
        assert!(!config.reflector.extract_errors);
        assert_eq!(config.context.max_recent_entries, 5);
        assert!(!config.context.include_all_successes);
        assert_eq!(config.context.max_context_chars, 2000);
    }

    #[tokio::test]
    async fn test_save_config() {
        let temp_dir = TempDir::new().unwrap();
        let loader = ACEConfigLoader::new(temp_dir.path());

        // Create custom configuration
        let mut config = ACEConfig::default();
        config.enabled = false;
        config.max_entries = 999;

        // Save
        loader.save(&config).await.unwrap();

        // Reload and verify
        let loaded = loader.load().await.unwrap();
        assert!(!loaded.enabled);
        assert_eq!(loaded.max_entries, 999);
    }
}
